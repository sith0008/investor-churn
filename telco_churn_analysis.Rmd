---
title: "R Notebook"
#output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

```{r}
library(dplyr)
library(scales)
library(ggplot2)
library(corrplot)
library(gridExtra)
library(ggthemes)
library(caret)
library(MASS)
library(randomForest)
library(party)
library(MLmetrics)
library(rpart)
library(rpart.plot)
library(precrec)
```

```{r}
telcoChurn <- read.csv(file = 'telco_churn_edited.csv')
telcoChurn = subset(telcoChurn, select=-c(customerID))
telcoChurn$Churn <- as.factor(telcoChurn$Churn)
telcoChurn <- na.omit(telcoChurn)

```

```{r}
tenureCounts <- table(telcoChurn$tenure)
barplot(
  tenureCounts,
  main="Tenure Distribution",
  xlab="Tenure",
  col="skyblue",
  border=F
)
```
```{r}
# percentage exited for each tenure
tenure <- telcoChurn %>% count(Churn, tenure)
tenure$Churn <- as.factor(tenure$Churn)
tenure$Churn <- ifelse(tenure$Churn == "No", "No Churn", "Churned")

ggplot(tenure, aes(fill=Churn, y=n, x=tenure))+
  geom_bar(position="fill", stat="identity")+
  scale_fill_manual(values = c("skyblue", scales::alpha("red", .5)))

```
```{r}
# boxplot for tenure against churn
boxplot(
  tenure ~ Churn, 
  data=telcoChurn, 
  main="Tenure against Churn",
  xlab="Churned",
  ylab="Tenure"
  )
```

```{r}
ContractType <- table(telcoChurn$Contract)
barplot(
  ContractType,
  main="Contract Type Distribution",
  xlab="Contract",
  col="skyblue",
  border=F
)
```
```{r}
# percentage exited for each contract type
Contract <- telcoChurn %>% count(Churn, Contract)
Contract$Churn <- as.factor(Contract$Churn)
Contract$Churn <- ifelse(Contract$Churn == "No", "No Churn", "Churned")

ggplot(Contract, aes(fill=Churn, y=n, x=Contract))+
  geom_bar(position="fill", stat="identity")+
  scale_fill_manual(values = c("skyblue", scales::alpha("red", .5)))
```

```{r}
MonthlyChargesCounts <- table(telcoChurn$MonthlyChargesIntervals)
barplot(
  MonthlyChargesCounts,
  main="Monthly Charges Distribution",
  xlab="Monthly Charges",
  col="skyblue",
  border=F
)
```
```{r}
# percentage exited for Montly Charge Range
MonthlyChargesIntervals <- telcoChurn %>% count(Churn, MonthlyChargesIntervals)
MonthlyChargesIntervals$Churn <- as.factor(MonthlyChargesIntervals$Churn)
MonthlyChargesIntervals$Churn <- ifelse(MonthlyChargesIntervals$Churn == "No", "No Churn", "Churned")


ggplot(MonthlyChargesIntervals, aes(fill=Churn, y=n, x=MonthlyChargesIntervals))+
  geom_bar(position="fill", stat="identity")+
  scale_fill_manual(values = c("skyblue", scales::alpha("red", .5)))
```
```{r}
# boxplot for monthly charges against churn
boxplot(
  MonthlyCharges ~ Churn, 
  data=telcoChurn, 
  main="Monthly Charges against Churned",
  xlab="Churned",
  ylab="Monthly Charges"
  )
```

```{r}
TotalChargesCounts <- table(telcoChurn$TotalChargesIntervals)
barplot(
  TotalChargesCounts,
  main="Total Charges Distribution",
  xlab="Total Charges",
  col="skyblue",
  border=F
)
```
```{r}
# percentage exited for Montly Charge Range
TotalChargesIntervals <- telcoChurn %>% count(Churn, TotalChargesIntervals)
TotalChargesIntervals$Churn <- as.factor(TotalChargesIntervals$Churn)
TotalChargesIntervals$Churn <- ifelse(TotalChargesIntervals$Churn == "No", "No Churn", "Churned")


ggplot(TotalChargesIntervals, aes(fill=Churn, y=n, x=TotalChargesIntervals))+
  geom_bar(position="fill", stat="identity")+
  scale_fill_manual(values = c("skyblue", scales::alpha("red", .5)))
```

```{r}
SeniorCitizenscount <- table(telcoChurn$SeniorCitizen)
barplot(
  SeniorCitizenscount,
  main="Senior Citizen Ratio",
  xlab="Senior Citizen",
  col="skyblue",
  border=F
)
```
```{r}
# percentage exited for Montly Charge Range
SeniorCitizen <- telcoChurn %>% count(Churn, SeniorCitizen)
SeniorCitizen$Churn <- as.factor(SeniorCitizen$Churn)
SeniorCitizen$Churn <- ifelse(SeniorCitizen$Churn == "No", "No Churn", "Churned")


ggplot(SeniorCitizen, aes(fill=Churn, y=n, x=SeniorCitizen))+
  geom_bar(position="fill", stat="identity")+
  scale_fill_manual(values = c("skyblue", scales::alpha("red", .5)))
```

```{r}
# train test split
idx = createDataPartition(telcoChurn$Churn, p=0.7, list=FALSE)
set.seed(42)
train = telcoChurn[idx,]
test = telcoChurn[-idx,]

train$Churn = ifelse(train$Churn == "Yes",1,0)
test$Churn = ifelse(test$Churn == "Yes",1,0)
train$Churn = as.factor(train$Churn)
test$Churn = as.factor(test$Churn)

dim(train); dim(test)
```

```{r}
# logistic regression to predict churn
logreg = glm(Churn ~ .,
             family=binomial(link="logit"),
             data=train)

print(summary(logreg))

```
```{r}
# feature importance: the steeper the drop in deviance the more important the feature
anova(logreg, test="Chisq")
```
```{r}
# evaluating logistic regression model against test data
results <- predict(logreg,newdata=test,type='response')
results <- ifelse(results > 0.5,1,0)
misclassError <- mean(results != test$Churn)
print(paste('Logistic Regression Accuracy',1-misclassError))
```
```{r}
print("Confusion Matrix for Logistic Regression"); table(Predicted = results, Actual = test$Churn)
```
```{r}
precrec.logreg <- evalmod(scores = results, labels = test$Churn)
print(precrec.logreg)
```
```{r}
autoplot(precrec.logreg)
```

```{r}
cart <- rpart(Churn ~ ., 
              data=train, 
              method = 'class', 
              control=rpart.control(minsplit = 2, cp = 0)
              )
plotcp(cart)
```
```{r}
CVerror.cap <- cart$cptable[which.min(cart$cptable[,"xerror"]), "xerror"] + cart$cptable[which.min(cart$cptable[,"xerror"]), "xstd"]

# Find the optimal CP region whose CV error is just below CVerror.cap in maximal tree cart1.
i <- 1; j<- 4
while (cart$cptable[i,j] > CVerror.cap) {
  i <- i + 1
}

# Get geometric mean of the two identified CP values in the optimal region if optimal tree has at least one split.
cp.opt = ifelse(i > 1, sqrt(cart$cptable[i,1] * cart$cptable[i-1,1]), 1)
```

```{r}
cart.opt <- prune(cart, cp = cp.opt)
cart.opt$variable.importance

```


```{r}
tree.pred <- predict(cart.opt, test, type="class")
table.pred <- table(Predicted = tree.pred, Actual = test$Churn)
print(paste('Decision Tree Accuracy',sum(diag(table.pred))/sum(table.pred)))
```
```{r}
# Note: accuracy is 80% because of unbalanced dataset; most data points have Churn = 0. From the confusion matrix, we can see that there are a lot of false negatives
print("Confusion Matrix for Decision Tree"); table(Predicted = tree.pred, Actual = test$Churn)
```

```{r}
precrec.tree <- evalmod(scores = c(tree.pred), labels = test$Churn)
print(precrec.tree)
```
```{r}
autoplot(precrec.tree)
```

```{r}
telcoChurn$gender <- as.factor(telcoChurn$gender)
telcoChurn$SeniorCitizen <- as.factor(telcoChurn$SeniorCitizen)
telcoChurn$Partner <- as.factor(telcoChurn$Partner)
telcoChurn$Dependents <- as.factor(telcoChurn$Dependents)
telcoChurn$PhoneService <- as.factor(telcoChurn$PhoneService)
telcoChurn$MultipleLines <- as.factor(telcoChurn$MultipleLines)
telcoChurn$InternetService <- as.factor(telcoChurn$InternetService)
telcoChurn$OnlineSecurity <- as.factor(telcoChurn$OnlineSecurity)
telcoChurn$OnlineBackup <- as.factor(telcoChurn$OnlineBackup)
telcoChurn$DeviceProtection <- as.factor(telcoChurn$DeviceProtection)
telcoChurn$TechSupport <- as.factor(telcoChurn$TechSupport)
telcoChurn$StreamingTV <- as.factor(telcoChurn$StreamingTV)
telcoChurn$StreamingMovies <- as.factor(telcoChurn$StreamingMovies)
telcoChurn$Contract <- as.factor(telcoChurn$Contract)
telcoChurn$PaperlessBilling <- as.factor(telcoChurn$PaperlessBilling)
telcoChurn$PaymentMethod <- as.factor(telcoChurn$PaymentMethod)
telcoChurn$MonthlyChargesIntervals <- as.factor(telcoChurn$MonthlyChargesIntervals)
telcoChurn$TotalChargesIntervals <- as.factor(telcoChurn$TotalChargesIntervals)
telcoChurn$OnlineSecurity <- as.factor(telcoChurn$OnlineSecurity)

# r forest
str(telcoChurn)
```
```{r}
set.seed(42)
# telcoChurn.imputed <- rfImpute(Churn ~ ., data = telcoChurn, iter = 6)
```
```{r}
rfmodel <- randomForest(Churn ~ ., data = telcoChurn, proximity = TRUE)
```
```{r}
rfmodel
```
```{r}
# model based on err.rate matrix: [OOB, No, Yes]
oob.error.data <- data.frame(Trees=rep(1:nrow(rfmodel$err.rate), times=3), Type=rep(c("OOB", "No", "Yes"), each=nrow(rfmodel$err.rate)), Error=c(rfmodel$err.rate[,"OOB"], rfmodel$err.rate[,"No"], rfmodel$err.rate[,"Yes"]))

ggplot(data=oob.error.data, aes(x=Trees, y=Error))+geom_line(aes(color=Type))
```
```{r}
# optimize no. of variables at each internal node in tree
oob.values <- vector(length=10)
for(i in 1:10){
  temp.model <- randomForest(Churn ~ ., data = telcoChurn, mtry=i, ntree=1000)
  
  #store OOB error rate for each random forest that uses diff value of i
  oob.values[i] <- temp.model$err.rate[nrow(temp.model$err.rate),1]
}

oob.values
```
```{r}
# no. of variables = 2 gives lowest oob err.rate

rfmodeloptim <- randomForest(Churn ~ ., data = telcoChurn, mtry=2, proximity = TRUE)
```
```{r}
rfmodeloptim
# error rate reduced
```
```{r}
rfmodeloptim.pred <- predict(rfmodeloptim, test)
table.rfmodeloptim.pred <- table(Predicted = rfmodeloptim.pred, Actual = test$Churn)
print(paste('Random Forest Accuracy',sum(diag(table.rfmodeloptim.pred))/sum(table.rfmodeloptim.pred)))
```
```{r}
print("Confusion Matrix for Random Forest"); table(Predicted = rfmodeloptim.pred, Actual = test$Churn)
```
```{r}
test$Churn = ifelse(test$Churn == "Yes",1,0) # this cannot be a factor for labels below
precrec.rf <- evalmod(scores = c(rfmodeloptim.pred), labels = test$Churn)
print(precrec.rf)
```
```{r}
autoplot(precrec.rf)
```
```{r}
oob.error.data <- data.frame(Trees=rep(1:nrow(rfmodel$err.rate), times=3), Type=rep(c("OOB", "No", "Yes"), each=nrow(rfmodeloptim$err.rate)), Error=c(rfmodeloptim$err.rate[,"OOB"], rfmodeloptim$err.rate[,"No"], rfmodeloptim$err.rate[,"Yes"]))

ggplot(data=oob.error.data, aes(x=Trees, y=Error))+geom_line(aes(color=Type))
```

```{r}
distance.matrix <- dist(1-rfmodeloptim$proximity)

mds.stuff <- cmdscale(distance.matrix, eig=TRUE, x.ret=TRUE)
mds.var.per <- round(mds.stuff$eig/sum(mds.stuff$eig)*100,1)
mds.values <- mds.stuff$points

mds.data <- data.frame(Sample=rownames(mds.values), X=mds.values[,1], Y=mds.values[,2], Status=data.imputed$hd)

ggplot(data=mds.data, aes(x=X, y=Y, label=Sample)) +
  geom_text(aes(color=Status)) +
  theme_bw() +
  xlab(paste("MDS1 - ", mds.var.per[1], "%", sep="")) +
  ylab(paste("MDS2 - ", mds.var.per[2], "%", sep="")) +
  ggtitle("MDS plot using (1 - Random Forest Proximities)")
```

```{r}
imp.logreg <- varImp(logreg, scale = FALSE)
imp.logreg
```

```{r}
imp.tree <- varImp(cart.opt, scale = FALSE)
imp.tree
```

```{r}
imp.rfmodeloptim <- varImp(rfmodeloptim, scale = FALSE)
imp.rfmodeloptim
```


